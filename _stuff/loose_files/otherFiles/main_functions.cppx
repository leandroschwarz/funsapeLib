
#include "myMain.hpp"

void processAdc1DmaData(bool isFirstBank_p)
{
	uint16_t index = (isFirstBank_p) ? 0 : adc1DmaBuffSizeHalf;

	if(!adc1CircBuffer.pushBuffer(&adc1DmaBuffer[index], adc1DmaBuffSizeHalf)) {
		funsapeStatus = adc1CircBuffer.getLastError();
		myErrorHandler((uint16_t)funsapeStatus);
	}

	// Returns successfully
	return;
}

void processAdc3DmaData(bool isFirstBank_p)
{
	// // Initializing variables
	// uint32_t rawRtcBatteryVoltage = 0;
	// uint32_t rawMainBatteryVoltage = 0;
	// uint32_t rawStepUpConverterVoltage = 0;

	// // Reading data from DMA buffer
	// if(isFirstBank_p) {
	// 	rawRtcBatteryVoltage = (uint32_t)batteryVoltagesDmaBuffer[0];
	// 	rawMainBatteryVoltage = (uint32_t)batteryVoltagesDmaBuffer[1];
	// 	rawStepUpConverterVoltage = (uint32_t)batteryVoltagesDmaBuffer[2];
	// } else {
	// 	rawRtcBatteryVoltage = (uint32_t)batteryVoltagesDmaBuffer[0 + BAT_ADC_DMA_BUFF_SIZE_HALF];
	// 	rawMainBatteryVoltage = (uint32_t)batteryVoltagesDmaBuffer[1 + BAT_ADC_DMA_BUFF_SIZE_HALF];
	// 	rawStepUpConverterVoltage = (uint32_t)batteryVoltagesDmaBuffer[2 + BAT_ADC_DMA_BUFF_SIZE_HALF];
	// }

	// // Calculate CR2032 voltage
	// rawRtcBatteryVoltage *= 825;
	// rawRtcBatteryVoltage /= 1024;
	// systemVoltages.rtcBattery = (uint16_t)rawRtcBatteryVoltage;

	// // Calculate Main Battery voltage
	// rawMainBatteryVoltage *= 825;
	// rawMainBatteryVoltage *= (POWER_MAIN_BAT_RES_TOP + POWER_MAIN_BAT_RES_BOTTOM);
	// rawMainBatteryVoltage /= (1024 * POWER_MAIN_BAT_RES_BOTTOM);
	// systemVoltages.mainBattery = (uint16_t)rawMainBatteryVoltage;

	// // Calculate Step Up converter voltage
	// rawStepUpConverterVoltage *= 825;
	// rawStepUpConverterVoltage *= (POWER_STEP_UP_RES_TOP + POWER_STEP_UP_RES_BOTTOM);
	// rawStepUpConverterVoltage /= (1024 * POWER_STEP_UP_RES_BOTTOM);
	// systemVoltages.stepUpConverter = (uint16_t)rawStepUpConverterVoltage;

	// // Signalizing that new voltage values are available
	// systemFlags.systemVoltagesUpdated = true;

	// Returns successfully
	return;
}











// //     ///////////    SYSTEM VOLTAGES (ADC3 + TIMER8)     ///////////     //
// #if !(DEBUG_DISABLE_ADC)
// 	halStatus = HAL_ADC_Start_DMA(&hadc3, (uint32_t *)(batteryVoltagesDmaBuffer), BAT_ADC_DMA_BUFF_SIZE);
// 	verboseStatus((uint16_t)halStatus, "ADC3 configured to use DMA\r");
// 	debugMessage((uint16_t)halStatus);
// 	if((uint16_t)halStatus) {
// 		myErrorHandler(ADC3_DMA_CONFIG);
// 	}
// 	halStatus = HAL_TIM_Base_Start_IT(&htim8);
// 	verboseStatus((uint16_t)halStatus, "TIMER8 configured\r");
// 	debugMessage((uint16_t)halStatus);
// 	if((uint16_t)halStatus) {
// 		myErrorHandler(TIMER8_CONFIG);
// 	}
// 	systemVoltages.rtcBattery = 0;
// 	systemVoltages.mainBattery = 0;
// 	systemVoltages.stepUpConverter = 0;
// #endif

// //     ///////////////////     ROTARY ENCODER     ///////////////////     //
// 	encoder.value = 0;
// 	encoder.ticksSinceLastEdge = 0;
// 	encoder.ticksSinceLastPress = 0;
// 	encoder.rotation = Rotation::CLOCKWISE;

// //     ///////////////////     CONFIGURE SPI1     ///////////////////     //

// 	if(!spi1.init(&hspi1)) {
// 		funsapeStatus = spi1.getLastError();
// 		debugMessage((uint16_t)funsapeStatus);
// 		myErrorHandler(SPI_CLASS_INIT);
// 	}

// //     ///////////////////////    SD CARD     ///////////////////////     //
// #if !(DEBUG_DISABLE_SD)
// 	funsapeStatus = sdCardCircBuffer.getLastError();
// 	if(funsapeStatus != Error::NONE) {
// 		debugMessage((uint16_t)funsapeStatus);
// 		myErrorHandler(SD_CIRC_BUFF_INIT);
// 	}
// // SD card mounting
// 	sdCard.result = f_mount(&sdCard.disk, "", 1);
// 	verboseStatus((uint16_t)sdCard.result, "SD Card volume mounted\r");
// 	debugMessage((uint16_t)sdCard.result);
// 	if(sdCard.result) {
// 		sdCard.diskIsMounted = false;
// 		myErrorHandler(SD_CARD_MOUNT);
// 	} else {
// 		sdCard.diskIsMounted = true;
// 	}
// // Search for last created file
// 	sdCard.fileNumber = 1;
// 	do {
// 		sprintf(sdCard.fileName, "file%04u.txt", sdCard.fileNumber);
// 		sdCard.result = f_open(&sdCard.fileHandler, sdCard.fileName, (BYTE)(FA_WRITE | FA_CREATE_NEW));
// 		if(!sdCard.result) {
// 			break;
// 		}
// 	} while((++sdCard.fileNumber) <= 9999);
// 	verboseStatus((uint16_t)sdCard.result, "New file created\r");
// 	debugMessage((uint16_t)sdCard.result);
// 	if(sdCard.result) {
// 		sdCard.fileIsOpenned = false;
// 		myErrorHandler(SD_CARD_OPEN_FILE);
// 	} else {
// 		sdCard.fileIsOpenned = true;
// 	}
// // Saving empty file
// 	sdCard.result = f_sync(&sdCard.fileHandler);
// 	verboseStatus((uint16_t)sdCard.result, "Empty file saved\r");
// 	debugMessage((uint16_t)sdCard.result);
// 	if(sdCard.result) {
// 		myErrorHandler(SD_CARD_SAVE_FILE);
// 	}
// // Closing file
// 	sdCard.result = f_close(&sdCard.fileHandler);
// 	verboseStatus((uint16_t)sdCard.result, "Empty file closed\r");
// 	debugMessage((uint16_t)sdCard.result);
// 	if(sdCard.result) {
// 		myErrorHandler(SD_CARD_CLOSE_FILE);
// 		sdCard.fileIsOpenned = false;
// 	}
// // SD card umounting
// 	sdCard.result = f_mount(NULL, "", 0);
// 	verboseStatus((uint16_t)sdCard.result, "SD Card unmounted\r");
// 	debugMessage((uint16_t)sdCard.result);
// 	if(sdCard.result) {
// 		myErrorHandler(SD_CARD_CLOSE_FILE);
// 		sdCard.diskIsMounted = false;
// 	}
// #endif

// //     ///////////////////     RESP (MPU9250)     ///////////////////     //
// #if !(DEBUG_DISABLE_MPU)
// 	if(!mpu0.init(&spi1, mpu0SelectDevice, mpu0DeselectDevice)) {
// 		funsapeStatus = mpu0.getLastError();
// 		debugMessage((uint16_t)funsapeStatus);
// 		myErrorHandler(RESP_MPU9250_INIT);
// 	}
// 	if(!mpu1.init(&spi1, mpu1SelectDevice, mpu1DeselectDevice)) {
// 		funsapeStatus = mpu1.getLastError();
// 		debugMessage((uint16_t)funsapeStatus);
// 		myErrorHandler(RESP_MPU9250_INIT);
// 	}
// 	if(!mpu2.init(&spi1, mpu2SelectDevice, mpu2DeselectDevice)) {
// 		funsapeStatus = mpu2.getLastError();
// 		debugMessage((uint16_t)funsapeStatus);
// 		myErrorHandler(RESP_MPU9250_INIT);
// 	}
// 	if(!mpu3.init(&spi1, mpu3SelectDevice, mpu3DeselectDevice)) {
// 		funsapeStatus = mpu3.getLastError();
// 		debugMessage((uint16_t)funsapeStatus);
// 		myErrorHandler(RESP_MPU9250_INIT);
// 	}

// 	if(!mpu0.configAccel(Mpu9250::AccelConfig::FREQ_4_KHZ_FILTER_FREQ_1046_HZ, Mpu9250::AccelFullScale::FULL_SCALE_2_G)) {
// 		funsapeStatus = mpu0.getLastError();
// 		debugMessage((uint16_t)funsapeStatus);
// 		myErrorHandler(RESP_MPU9250_CONFIG_ACCEL);
// 	}
// 	if(!mpu1.configAccel(Mpu9250::AccelConfig::FREQ_4_KHZ_FILTER_FREQ_1046_HZ, Mpu9250::AccelFullScale::FULL_SCALE_2_G)) {
// 		funsapeStatus = mpu1.getLastError();
// 		debugMessage((uint16_t)funsapeStatus);
// 		myErrorHandler(RESP_MPU9250_CONFIG_ACCEL);
// 	}
// 	if(!mpu2.configAccel(Mpu9250::AccelConfig::FREQ_4_KHZ_FILTER_FREQ_1046_HZ, Mpu9250::AccelFullScale::FULL_SCALE_2_G)) {
// 		funsapeStatus = mpu2.getLastError();
// 		debugMessage((uint16_t)funsapeStatus);
// 		myErrorHandler(RESP_MPU9250_CONFIG_ACCEL);
// 	}
// 	if(!mpu3.configAccel(Mpu9250::AccelConfig::FREQ_4_KHZ_FILTER_FREQ_1046_HZ, Mpu9250::AccelFullScale::FULL_SCALE_2_G)) {
// 		funsapeStatus = mpu3.getLastError();
// 		debugMessage((uint16_t)funsapeStatus);
// 		myErrorHandler(RESP_MPU9250_CONFIG_ACCEL);
// 	}
// #endif

// //     ///////////////////     CONFIGURE I2C1     ///////////////////     //
// 	if(!twi1.init(&hi2c1)) {
// 		funsapeStatus = twi1.getLastError();
// 		debugMessage((uint16_t)funsapeStatus);
// 		myErrorHandler(TWI_CLASS_INIT);
// 	}
// 	if(!twi1.setAddress(0x68, false)) {
// 		funsapeStatus = twi1.getLastError();
// 		debugMessage((uint16_t)funsapeStatus);
// 		myErrorHandler(TWI_CLASS_INIT);
// 	}

// 	while(1) {
// 		uint8_t aux[4];

// 		if(!twi1.readReg(0x75, aux, 1)) {
// 			funsapeStatus = twi1.getLastError();
// 			debugMessage((uint16_t)funsapeStatus);
// 			myErrorHandler(TWI_CLASS_INIT);
// 		}
// 		debugMessage((uint16_t)aux[0]);
// 		ledToggle();
// 		delayMs(100);
// 	}

// //     //////////////////////////////////////////////////////////////     //
// //     ////////////////////     TESTING CODE     ////////////////////     //
// //     //////////////////////////////////////////////////////////////     //
// #if !(DEBUG_DISABLE_MPU)
// 	for(uint16_t i = 0; i < 1000; i++) {
// 		sdCardCircBuffer.push((uint8_t)i);
// 	}
// 	char auxString[1000];
// 	sprintf(auxString, "%u\r", sdCardCircBuffer.getOccupation());
// 	HAL_UART_Transmit(&huart3, (uint8_t *)auxString, strlen(auxString), uart3TimeoutUART3_TIMEOUT);

// 	while(1) {
// 		char auxString[1000];
// 		int16_t accelBuff[3] = {0, 0, 0};

// 		if(!mpu0.getAccelData(accelBuff)) {
// 			myErrorHandler(4);
// 		}
// 		sprintf(auxString, "%08d %08d %08d \r", accelBuff[0], accelBuff[1], accelBuff[2]);
// 		HAL_UART_Transmit(&huart3, (uint8_t *)auxString, strlen(auxString), uart3TimeoutUART3_TIMEOUT);

// 		if(!mpu0.getAccelOffset(accelBuff)) {
// 			myErrorHandler(5);
// 		}
// 		sprintf(auxString, "%08d %08d %08d \r\r", accelBuff[0], accelBuff[1], accelBuff[2]);
// 		HAL_UART_Transmit(&huart3, (uint8_t *)auxString, strlen(auxString), uart3TimeoutUART3_TIMEOUT);

// 		ledToggle();
// 		delayMs(200);
// 	}
// #endif


void processEventEncoderRotation(void)
{
	// TODO: Action when encoder is rotated

	return;
}

void processEventEncoderButtonPress(void)
{
	// TODO: Action when encoder button is pressed

	return;
}

void processEventSystemVoltagesUpdated(void)
{
	// TODO: Action when new values of system voltage is available

	return;
}

void processEventAcquisitionStartNew(void)
{
	// TODO: Start the devices and create a new file

	return;
}

// void processEventSdCardWriteData(void)
// {
// 	// Pop data from circular buffer
// 	uint8_t sdCardBuff[SD_CARD_BUFF_SIZE];
// 	sdCardCircBuffer.popBuffer(sdCardBuff, SD_CARD_BUFF_SIZE);
// 	// SD card mounting
// 	sdCard.result = f_mount(&sdCard.disk, "", 1);
// 	verboseStatus((uint16_t)sdCard.result, "SD Card volume mounted\r");
// 	debugMessage((uint16_t)sdCard.result);
// 	if(sdCard.result) {
// 		sdCard.diskIsMounted = false;
// 		myErrorHandler(SD_CARD_MOUNT);
// 	} else {
// 		sdCard.diskIsMounted = true;
// 	}
// 	// Open last created file for append
// 	sdCard.result = f_open(&sdCard.fileHandler, sdCard.fileName, (BYTE)(FA_WRITE | FA_OPEN_ALWAYS));
// 	verboseStatus((uint16_t)sdCard.result, "File opened for write operation\r");
// 	debugMessage((uint16_t)sdCard.result);
// 	if(sdCard.result) {
// 		sdCard.fileIsOpenned = false;
// 		myErrorHandler(SD_CARD_OPEN_FILE);
// 	} else {
// 		sdCard.fileIsOpenned = true;
// 	}
// 	sdCard.result = f_lseek(&sdCard.fileHandler, f_size(&sdCard.fileHandler));
// 	verboseStatus((uint16_t)sdCard.result, "Moving pointer to append data\r");
// 	debugMessage((uint16_t)sdCard.result);
// 	if(sdCard.result) {
// 		sdCard.fileIsOpenned = false;
// 		myErrorHandler(SD_CARD_OPEN_FILE);
// 	} else {
// 		sdCard.fileIsOpenned = true;
// 	}
// 	// Writing data
// 	UINT bytesWrote;
// 	sdCard.result = f_write(&sdCard.fileHandler, sdCardBuff, SD_CARD_BUFF_SIZE, &bytesWrote);
// 	verboseStatus((uint16_t)sdCard.result, "Data written to file\r");
// 	debugMessage((uint16_t)sdCard.result);
// 	if(sdCard.result) {
// 		myErrorHandler(SD_CARD_WRITE_FILE);
// 	}
// 	// Saving empty file
// 	sdCard.result = f_sync(&sdCard.fileHandler);
// 	verboseStatus((uint16_t)sdCard.result, "File saved\r");
// 	debugMessage((uint16_t)sdCard.result);
// 	if(sdCard.result) {
// 		myErrorHandler(SD_CARD_SAVE_FILE);
// 	}
// 	// Closing file
// 	sdCard.result = f_close(&sdCard.fileHandler);
// 	verboseStatus((uint16_t)sdCard.result, "File closed\r");
// 	debugMessage((uint16_t)sdCard.result);
// 	if(sdCard.result) {
// 		myErrorHandler(SD_CARD_CLOSE_FILE);
// 		sdCard.fileIsOpenned = false;
// 	}
// 	// SD card umounting
// 	sdCard.result = f_mount(NULL, "", 0);
// 	verboseStatus((uint16_t)sdCard.result, "SD Card unmounted\r");
// 	debugMessage((uint16_t)sdCard.result);
// 	if(sdCard.result) {
// 		myErrorHandler(SD_CARD_CLOSE_FILE);
// 		sdCard.diskIsMounted = false;
// 	}

// 	return;
// }
