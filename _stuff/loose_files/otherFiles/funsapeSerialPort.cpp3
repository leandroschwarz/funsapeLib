//---------------------------------------------------------------------------

#pragma hdrstop

#include "funsapeSerialPort.h"
//---------------------------------------------------------------------------
#pragma package(smart_init)


// Events
#define SIG_POWER_DOWN              0
#define SIG_READER                  1
#define SIG_READ_DONE               2       // data received has been read
#define SIG_WRITER                  3
#define SIG_DATA_TO_TX              4       // data waiting to be sent
#define SIG_MODEM_EVENTS            5
#define SIG_MODEM_CHECKED           6

#define EXIT_TIMEOUT                2000


void funsapeSerialPortThreadStart(void *arg);
wchar_t *AnsiToWchar_t(AnsiString auxAnsiString);

typedef unsigned(WINAPI *PBEGINTHREADEX_THREADFUNC)(LPVOID lpThreadParameter);
typedef unsigned *PBEGINTHREADEX_THREADID;

//     ///////////////////////    CONSTRUCTOR     ///////////////////////     //

funsapeSerialPort::funsapeSerialPort(CircularBuffer<uint8_t> *rxBuffer_p)
{
	// Update data members
	this->_dcb                          = {0};
	this->_isOpenned                    = false;
	this->_isReady                      = false;
	this->_isRxInProgress               = false;
	this->_isTxInProgress               = false;
	this->_isWaitCommEventInProgress    = false;
	this->_maxRxTempBuffer              = 1;
	this->_ovReader                     = {0};
	this->_ovWriter                     = {0};
	this->_ovWaitEvent                  = {0};
	this->_rxBuffer                     = rxBuffer_p;
	this->_rxTempBufferLength           = 0;
	this->_txTempBufferLength           = 0;

	// Create events for the different sources
	for(int i = 0; i < SERIAL_SIGNAL_NBR; i++) {
		if((i == SIG_READER) || (i == SIG_WRITER) || (i == SIG_MODEM_EVENTS)) {
			this->_serialEvents[i] = CreateEvent(NULL, TRUE, FALSE, NULL);  // Manual Reset
		} else {
			this->_serialEvents[i] = CreateEvent(NULL, FALSE, FALSE, NULL); // Auto reset
		}
	}

	// Returns successfully
	this->_lastError = ErrorCode::NONE;
	return;
}

funsapeSerialPort::~funsapeSerialPort(void)
{
	// Delete thread handler
	if(this->_threadHandler != 0) {
		WaitForSingleObject(this->_threadHandler, EXIT_TIMEOUT);
	}
	this->_threadHandler = 0;

	// Delete the events
	for(int i = 0; i < SERIAL_SIGNAL_NBR; i++) {
		if(this->_serialEvents[i] != INVALID_HANDLE_VALUE) {
			CloseHandle(this->_serialEvents[i]);
		}
		this->_serialEvents[i] = INVALID_HANDLE_VALUE;
	}

	// Delete serial handler
	if(this->_serialHandler != INVALID_HANDLE_VALUE) {
		CloseHandle(this->_serialHandler);
	}
	this->_serialHandler = INVALID_HANDLE_VALUE;

	return;
}

//     /////////////////////////     STATUS     /////////////////////////     //

int funsapeSerialPort::getNbrOfBytes(void)
{
	struct _COMSTAT status;
	int             n;
	unsigned long   etat;

	n = 0;

	if(this->_serialHandler != INVALID_HANDLE_VALUE) {
		ClearCommError(this->_serialHandler, &etat, &status);
		n = status.cbInQue;
	}

	return(n);
}

//     //////////////////////    CONFIGURATION     //////////////////////     //

bool funsapeSerialPort::connect(uint16_t portNumber_p, uint32_t baudRate_p, DataBits dataBits_p, ParityMode parityMode_p, StopBits stopBits_p, PortDirection direction_p, FlowControl flowControl_p, PortSharing sharingFlags_p)
{
	// Local variables
	char            *auxPortName        = new char[10];
	DWORD           auxBaudRate         = 0;
	DWORD           auxDirection        = 0;
	DWORD           auxSharingFlags     = 0;
	BYTE            auxDataBits         = 0;
	BYTE            auxParityMode       = 0;
	BYTE            auxStopBits         = 0;
	DCB             auxDcb;
	COMMTIMEOUTS    auxTimeouts         = {0, 0, 0, 0, 0};
	bool            hard_handshake      = false;
	AnsiString auxString;

	// Check for error - port number
	if(portNumber_p > 255) {
		// Register error
		this->_lastError = ErrorCode::PORT_NUMBER_INVALID;
		// Call onDisconnect Event Callback
		if(!isPointerValid(this->_onDisconnectCallback)) {
			this->_onDisconnectCallback();
		}
		// Returns error
		return false;
	}


	// Process arguments

	// Disconnect if already connected
	if(this->_serialHandler != INVALID_HANDLE_VALUE) {
		// Close handler
		CloseHandle(this->_serialHandler);
		this->_serialHandler = INVALID_HANDLE_VALUE;
		// Call onDisconnect Event Callback
		if(!isPointerValid(this->_onDisconnectCallback)) {
			this->_onDisconnectCallback();
		}
	}

	// Clear overlapped events
	ZeroMemory(&this->_ovReader, sizeof(this->_ovReader));
	ZeroMemory(&this->_ovWriter, sizeof(this->_ovWriter));
	ZeroMemory(&this->_ovWaitEvent, sizeof(this->_ovWaitEvent));

	// Event serial port
	this->_ovReader.hEvent = this->_serialEvents[SIG_READER];
	this->_ovWriter.hEvent = this->_serialEvents[SIG_WRITER];
	this->_ovWaitEvent.hEvent = this->_serialEvents[SIG_MODEM_EVENTS];

	// Open serial port
	auxString = AnsiString(auxPortName);
	this->_serialHandler = CreateFile(AnsiToWchar_t(auxString), auxDirection, auxSharingFlags, NULL, OPEN_EXISTING,
					FILE_FLAG_OVERLAPPED, NULL);
	if(this->_serialHandler == INVALID_HANDLE_VALUE) {
		// Register error
		this->_lastError = ErrorCode::CREATE_HANDLER_ERROR;
		// Call onDisconnect Event Callback
		if(!isPointerValid(this->_onDisconnectCallback)) {
			this->_onDisconnectCallback();
		}
		// Returns error
		return false;
	}

	// Set of events to be monitored
	if(!SetCommMask(this->_serialHandler, 0)) {
		// Close handler
		CloseHandle(this->_serialHandler);
		this->_serialHandler = INVALID_HANDLE_VALUE;
		// Register error
		this->_lastError = ErrorCode::SET_EVENT_MASK_ERROR;
		// Call onDisconnect Event Callback
		if(!isPointerValid(this->_onDisconnectCallback)) {
			this->_onDisconnectCallback();
		}
		// Returns error
		return false;
	}

	// Set timeouts
	if(!SetCommTimeouts(this->_serialHandler, &auxTimeouts)) {
		// Close handler
		CloseHandle(this->_serialHandler);
		this->_serialHandler = INVALID_HANDLE_VALUE;
		// Register error
		this->_lastError = ErrorCode::SET_TIMEOUTS_ERROR;
		// Call onDisconnect Event Callback
		if(!isPointerValid(this->_onDisconnectCallback)) {
			this->_onDisconnectCallback();
		}
		// Returns error
		return false;
	}

	// Clear DCB struct
	memset(&auxDcb, 0, sizeof(DCB));


	// Set DCB struct
	if(!SetCommState(this->_serialHandler, &auxDcb)) {
		// Close handler
		CloseHandle(this->_serialHandler);
		this->_serialHandler = INVALID_HANDLE_VALUE;
		// Register error
		this->_lastError = ErrorCode::SET_COMM_STATE_ERROR;
		// Call onDisconnect Event Callback
		if(!isPointerValid(this->_onDisconnectCallback)) {
			this->_onDisconnectCallback();
		}
		// Returns error
		return false;
	}

	// Check serial events
	for(int i = 0; i < SERIAL_SIGNAL_NBR; i++) {
		if(this->_serialEvents[i] == INVALID_HANDLE_VALUE) {
			// Close handler
			CloseHandle(this->_serialHandler);
			this->_serialHandler = INVALID_HANDLE_VALUE;
			// Register error
			this->_lastError = ErrorCode::CREATE_EVENT_ERROR;
			// Call onDisconnect Event Callback
			if(!isPointerValid(this->_onDisconnectCallback)) {
				this->_onDisconnectCallback();
			}
			// Returns error
			return false;
		}
	}

	// Start thread
	this->_threadHandler = (HANDLE)_beginthreadex(NULL, 0, (PBEGINTHREADEX_THREADFUNC)funsapeSerialPortThreadStart, this, 0, &this->_threadId);

	// Call onConnect Event Callback
	if(!isPointerValid(this->_onConnectCallback)) {
		this->_onConnectCallback();
	}

	// Register connection result
	this->_isOpenned = true;

	// Returns successfully
	this->_lastError = ErrorCode::NONE;
	return true;
}

// this function is the main loop of the Tserial object. There is a
// do while() loop executed until either an error or a PowerDown is
// received.
// this is not a busy wait since we use the WaitForMultipleObject function
void funsapeSerialPort::run(void)
{
	bool done = false;
	long          status;
	unsigned long read_nbr, result_nbr;
	char          success;

	// Checks connection
	if(!this->_isOpenned){
		// Just returns
		return;
	}

	// Update data members
	this->_isReady                      = true;
	this->_isRxInProgress               = false;
	this->_isTxInProgress               = false;
	this->_isWaitCommEventInProgress    = false;

	if(this->_managerFunction != 0) {
		this->_managerFunction((uint32_t)this, SERIAL_CONNECTED);
	}

	// Clears pending errors
	GetLastError();
	SetEvent(this->_serialEvents[SIG_READ_DONE]);

	while(!done) {
		// ---------------------------------------------------------------------
		// Wait for signals ----------------------------------------------------
		// ---------------------------------------------------------------------
		// Main wait function. Waiting for something to happen. This may be
		// either the completion of a Read or a Write or the reception of modem
		// events, Power Down, new Tx.
		// ---------------------------------------------------------------------
		status = WaitForMultipleObjects(SERIAL_SIGNAL_NBR, this->_serialEvents, FALSE, INFINITE);
		// Process answer to filter other failures
		status = status - WAIT_OBJECT_0;
		if((status < 0) || (status >= SERIAL_SIGNAL_NBR)) {
			// error
			done = true;
		} else {
			// Event dispatcher
			switch(status) {

			case SIG_POWER_DOWN:            // receiving a POWER down signal. Stopping the thread
				done = true;
				break;

			case SIG_READ_DONE:             // Rx
				// Checking last reading process
				if(!this->_isRxInProgress) {
					this->_isRxInProgress = true;
					success = (char)ReadFile(this->_serialHandler, &this->_rxTempBuffer, this->_maxRxTempBuffer, &read_nbr,
									&this->_ovReader);
					if(!success) {
						// Get error
						if(GetLastError() != ERROR_IO_PENDING) {
							// real failure => quiting
							done = true;
							// Returns error
							this->_lastError = ErrorCode::READ_FILE_ERROR;
						} else {
							// Do nothing - read is pending
						}
					} else {
						// Do nothing - since the overlapped will be
						// signaled anyway, so the processing wiil be taken
						// there
					}
				}
				break;

			case SIG_READER:            // Reading the result of the terminated read
				if(GetOverlappedResult(this->_serialHandler, &this->_ovReader, &result_nbr, FALSE)) {
					// Read operation completed successfully
					ResetEvent(this->_serialEvents[SIG_READER]);
					// Write operation completed successfully
					this->_rxTempBufferLength = result_nbr;
					this->_isRxInProgress = false;
					// Process incoming data
					if((result_nbr != 0) && (this->_managerFunction != 0)) {
						this->_managerFunction((uint32_t)this, SERIAL_DATA_ARRIVAL);
					}
				} else {
					// GetOverlapped didn't succeed!
					if(GetLastError() != ERROR_IO_PENDING) {
						done = true;
						// Returns error
						this->_lastError = ErrorCode::GET_OVERLAPPED_RESULT_ERROR;
					}
				}
				break;

			case SIG_DATA_TO_TX:        // Tx
				// Signal asserted that there is a new valid message in the
				// "txBuffer" variable sending data to the port
				success = (char)WriteFile(this->_serialHandler, this->_txTempBuffer, this->_txTempBufferLength, &result_nbr,
								&this->_ovWriter);
				if(!success) {
					// Get error
					if(GetLastError() != ERROR_IO_PENDING) {
						// real failure => quiting
						done = true;
						// Returns error
						this->_lastError = ErrorCode::WRITE_FILE_ERROR;
					} else {
						// Do nothing - write is pending
					}
				} else {
					// Do nothing - since the overlapped will be
					// signaled anyway, so the processing wiil be taken
					// there
				}
				break;

			case SIG_WRITER:            // WriteFile has terminated
				if(GetOverlappedResult(this->_serialHandler, &this->_ovWriter, &result_nbr, FALSE)) {
					// Write operation completed successfully
					ResetEvent(this->_serialEvents[SIG_WRITER]);
					// Write operation completed successfully
					this->_isTxInProgress = false;
					// Process incoming data
					if(this->_managerFunction != 0) {
						this->_managerFunction((uint32_t)this, SERIAL_DATA_SENT);
					}
				} else {
					// GetOverlapped didn't succeed!
					if(GetLastError() != ERROR_IO_PENDING) {
						done = true;
						// Returns error
						this->_lastError = ErrorCode::GET_OVERLAPPED_RESULT_ERROR;
					}
				}
				break;

			case SIG_MODEM_CHECKED:     // Modem events
				break;

			case SIG_MODEM_EVENTS:      // Reading the result of the terminated wait
//					if (GetOverlappedResult(this->_seriaHandler, &this->_ovWaitEvent, &result_nbr, FALSE)) {
//						// Wait operation completed successfully
//						ResetEvent(this->_serialEvents[SIG_MODEM_EVENTS]);
//						this->_isWaitCommEventInProgress = false;
//						// Process incoming data
//						OnEvent(dwCommEvent);
//						// automatically starting a new check
//						SetEvent(this->_serialEvents[SIG_MODEM_CHECKED]);
//					} else {
//						// GetOverlapped didn't succeed !
//						// What's the reason ?
//						if(GetLastError() != ERROR_IO_PENDING) {
//							done = true;
//						}
//					}
				break;
			} // switch(status)
		} // if((status < 0) || (status >= SERIAL_SIGNAL_NBR)
	} // while(!done)

	// Close handler
	this->_isReady = false;
	if(this->_serialHandler != INVALID_HANDLE_VALUE) {
		// Close handler
		CloseHandle(this->_serialHandler);
		this->_serialHandler = INVALID_HANDLE_VALUE;
		// Call onDisconnect Event Callback
		if(!isPointerValid(this->_onDisconnectCallback)) {
			this->_onDisconnectCallback();
		}
		this->_isOpenned = false;
	}

	if(this->_managerFunction != 0) {
		this->_managerFunction((uint32_t)this, SERIAL_DISCONNECTED);
	}

	return;
}

bool funsapeSerialPort::setManagerFunction(void (*managerFunction_p)(uint32_t object_p, uint32_t event_p))
{
	// Check for error - function pointer null
	if(!isPointerValid(managerFunction_p)) {
		// Returns error
		this->_lastError = ErrorCode::FUNCTION_POINTER_NULL;
		return false;
	}

	// Update data members
	this->_managerFunction = managerFunction_p;

	// Returns successfully
	this->_lastError = ErrorCode::NONE;
	return true;
}

bool funsapeSerialPort::setOnConnectCallback(void (*callbackFunction_p)(void))
{
	// Check for error - function pointer null
	if(!isPointerValid(callbackFunction_p)) {
		this->_onConnectCallback = nullptr;
		// Returns error
		this->_lastError = ErrorCode::FUNCTION_POINTER_NULL;
		return false;
	}

	// Update data members
	this->_onConnectCallback = callbackFunction_p;

	// Returns successfully
	this->_lastError = ErrorCode::NONE;
	return true;

}

bool funsapeSerialPort::setOnDisconnectCallback(void (*callbackFunction_p)(void))
{
	// Check for error - function pointer null
	if(!isPointerValid(callbackFunction_p)) {
		this->_onDisconnectCallback = nullptr;
		// Returns error
		this->_lastError = ErrorCode::FUNCTION_POINTER_NULL;
		return false;
	}

	// Update data members
	this->_onDisconnectCallback = callbackFunction_p;

	// Returns successfully
	this->_lastError = ErrorCode::NONE;
	return true;
}


bool funsapeSerialPort::setOnRescanPortCallback(void (*callbackFunction_p)(void))
{
	// Check for error - function pointer null
	if(!isPointerValid(callbackFunction_p)) {
		this->_onRescanPortCallback = nullptr;
		// Returns error
		this->_lastError = ErrorCode::FUNCTION_POINTER_NULL;
		return false;
	}

	// Update data members
	this->_onRescanPortCallback = callbackFunction_p;

	// Returns successfully
	this->_lastError = ErrorCode::NONE;
	return true;
}

bool funsapeSerialPort::scan(std::vector<AnsiString> *ports_p)
{
	// Checks connection
	if(this->_isOpenned) {
		this->disconnect();
	}

    //

	// Returns sucessfully
	return true;
}


void funsapeSerialPort::dataHasBeenRead(void)
{
	SetEvent(this->_serialEvents[SIG_READ_DONE]);

	return;
}

bool funsapeSerialPort::disconnect(void)
{
	this->_isReady = false;
	SetEvent(this->_serialEvents[SIG_POWER_DOWN]);

	if(this->_threadHandler != 0) {
		WaitForSingleObject(this->_threadHandler, EXIT_TIMEOUT);
	}
	this->_threadHandler = 0;

	return true;
}

//     /////////////////////    OTHER FUNCTIONS     /////////////////////     //

void funsapeSerialPortThreadStart(void *arg)
{
	class funsapeSerialPort *serialUnit;

	serialUnit = (funsapeSerialPort *)arg;

	if(serialUnit != 0) {
		serialUnit->run();
	}

	return;
}

wchar_t *AnsiToWchar_t(AnsiString auxAnsiString)
{
	wchar_t *str = new wchar_t[auxAnsiString.WideCharBufSize()];
	return auxAnsiString.WideChar(str, auxAnsiString.WideCharBufSize());
	delete[] str;
}

