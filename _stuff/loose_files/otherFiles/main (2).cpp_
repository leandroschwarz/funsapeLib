
#include "main.h"
#include "adc.h"
#include "crc.h"
#include "dma.h"
#include "i2c.h"
#include "spi.h"
#include "tim.h"
#include "usart.h"
#include "usb_device.h"
#include "gpio.h"

#include <stdio.h>
#include <string.h>
#include "..\FunSAPE\funsapeLibGlobalDefines.hpp"
#include "..\FunSAPE\funsapeLibCircularBuffer16.hpp"

typedef union {
	uint32_t allFields;
	struct : {
		uint32_t	mixedColor				: 3;
		uint32_t	mixedFastBlinks			: 3;
		uint32_t	mixedSlowBlinks			: 3;
		uint32_t	redFastBlinks			: 3;
		uint32_t	redSlowBlinks			: 3;
		uint32_t	greenFastBlinks			: 3;
		uint32_t	greenSlowBlinks			: 3;
		uint32_t	blueFastBlinks			: 3;
		uint32_t	blueSlowBlinks			: 3;
		uint32_t	unusedBits				: 5;
	};
} blinkWarning_s;

typedef enum : uint16_t {
	// General error codes
	ERROR_OK											= 0x0000,

	// ADC related error codes
	ERROR_ADC_UNKNOWN									= 0x0010,
	ERROR_ADC_CALIBRATION_FAILED						= 0x0011,
	ERROR_ADC_START_POOLING_FAILED						= 0x0012,
	ERROR_ADC_START_INTERRUPT_FAILED					= 0x0013,
	ERROR_ADC_START_DMA_FAILED							= 0x0014,

	// TIMER related error codes
	ERROR_TIMER_UNKNOWN									= 0x0020,
	ERROR_TIMER_BASETIME_START_POOLING_FAILED			= 0x0021,
	ERROR_TIMER_BASETIME_START_INTERRUPT_FAILED			= 0x0022,

	// UART related error codes
	ERROR_UART_UNKNOWN									= 0x0030,
	ERROR_UART_TRANSMIT_POLLING_FAILED					= 0x0031,
	ERROR_UART_TRANSMIT_INTERRUPT_FAILED				= 0x0032,
	ERROR_UART_TRANSMIT_DMA_FAILED						= 0x0033,

	// Unknow error - Ops... Something really bad happened, and we don't have a
	// 		clue of what the hell caused it! Good luck, bro!
	ERROR_GENERAL_UNKNOWN								= 0xFFFF
} errorCode_e;

typedef union {
	uint32_t allFlags;
	struct {
		bool uart1RxHalfComplete		: 1;
		bool uart1RxFullComplete		: 1;
		bool uart1TxHalfComplete		: 1;
		bool uart1TxFullComplete		: 1;
		uint32_t unusedFlags			: 28;
	};
} systemFlags_t;

#define ADC_CHANNELS_PER_SAMPLE			8
#define ADC_SAMPLES_PER_BUFFER			10
#define ADC_CHANNELS_PER_BUFFER			(ADC_CHANNELS_PER_SAMPLE * ADC_SAMPLES_PER_BUFFER)
#define ADC_DMA_BUFFER_ELEMENTS			ADC_CHANNELS_PER_BUFFER

#define ledTurnOn()						HAL_GPIO_WritePin(NLED_GPIO_Port, NLED_Pin, GPIO_PIN_RESET)
#define ledTurnOff()					HAL_GPIO_WritePin(NLED_GPIO_Port, NLED_Pin, GPIO_PIN_SET)
#define ledToggle()						HAL_GPIO_TogglePin(NLED_GPIO_Port, NLED_Pin)
#define redLedTurnOn()					HAL_GPIO_WritePin(LED_R_GPIO_Port, LED_R_Pin, GPIO_PIN_SET)
#define redLedTurnOff()					HAL_GPIO_WritePin(LED_R_GPIO_Port, LED_R_Pin, GPIO_PIN_RESET)
#define greenLedTurnOn()				HAL_GPIO_WritePin(LED_G_GPIO_Port, LED_G_Pin, GPIO_PIN_SET)
#define greenLedTurnOff()				HAL_GPIO_WritePin(LED_G_GPIO_Port, LED_G_Pin, GPIO_PIN_RESET)
#define blueLedTurnOn()					HAL_GPIO_WritePin(LED_B_GPIO_Port, LED_B_Pin, GPIO_PIN_SET)
#define blueLedTurnOff()				HAL_GPIO_WritePin(LED_B_GPIO_Port, LED_B_Pin, GPIO_PIN_RESET)

#define redLedBlinkFast()				do{redLedTurnOn();HAL_Delay(250);redLedTurnOff();HAL_Delay(250);}while(0)
#define redLedBlinkSlow()				do{redLedTurnOn();HAL_Delay(500);redLedTurnOff();HAL_Delay(500);}while(0)
#define greenLedBlinkFast()				do{greenLedTurnOn();HAL_Delay(250);greenLedTurnOff();HAL_Delay(250);}while(0)
#define greenLedBlinkSlow()				do{greenLedTurnOn();HAL_Delay(500);greenLedTurnOff();HAL_Delay(500);}while(0)
#define blueLedBlinkFast()				do{blueLedTurnOn();HAL_Delay(250);blueLedTurnOff();HAL_Delay(250);}while(0)
#define blueLedBlinkSlow()				do{blueLedTurnOn();HAL_Delay(500);blueLedTurnOff();HAL_Delay(500);}while(0)

volatile errorCode_e errorCode = ERROR_OK;
volatile systemFlags_t systemFlags;

void SystemClock_Config(void);
/* USER CODE BEGIN PFP */

/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */

/* USER CODE END 0 */

/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
	/* USER CODE BEGIN 1 */
	HAL_StatusTypeDef	halStatus;
	error_e				funsapeStatus;
	uint16_t			adcDmaBuffer[ADC_DMA_BUFFER_ELEMENTS];
	/* USER CODE END 1 */

	/* MCU Configuration--------------------------------------------------------*/

	/* Reset of all peripherals, Initializes the Flash interface and the Systick. */
	HAL_Init();

	/* USER CODE BEGIN Init */

	systemFlags.allFlags = 0;

	/* USER CODE END Init */

	/* Configure the system clock */
	SystemClock_Config();

	/* USER CODE BEGIN SysInit */

	/* USER CODE END SysInit */

	/* Initialize all configured peripherals */
	MX_GPIO_Init();
	MX_DMA_Init();
	MX_ADC1_Init();
	MX_CRC_Init();
	MX_I2C1_Init();
	MX_I2C2_Init();
	MX_SPI1_Init();
	MX_SPI2_Init();
	MX_TIM1_Init();
	MX_TIM2_Init();
	MX_TIM3_Init();
	MX_USART1_UART_Init();
	MX_USART2_UART_Init();
	MX_USB_DEVICE_Init();
	/* USER CODE BEGIN 2 */

	// =========================================================================
	// ADC configuration
	// =========================================================================
	//     Adc is configured to start a sequence of conversions when the TIM3
	// Update Event occurs. Each comversion sequence is composed by 7 channels
	// and the temperature channel. The samples are stored in a buffer using
	// DMA.
	// =========================================================================

	halStatus = HAL_ADCEx_Calibration_Start(&hadc1);
	if (halStatus != HAL_OK) {
		errorCode = ERROR_ADC_CALIBRATION_FAILED;
		Error_Handler();
	}
//	halStatus = HAL_ADC_Start_DMA(&hadc1, (uint32_t *)adcDmaBuffer, ADC_DMA_BUFFER_ELEMENTS);
//	if (halStatus != HAL_OK) {
//		errorCode = ERROR_ADC_START_DMA_FAILED;
//		Error_Handler();
//	}

	// =========================================================================
	// TIMER3 configuration
	// =========================================================================
	//     Timer 3 is configured to generate an interruption each 5ms (200 Hz).
	// This time base is also used by ADC to start a sequence of conversions.
	// =========================================================================
	halStatus = HAL_TIM_Base_Start_IT(&htim3);
	if (halStatus != HAL_OK) {
		errorCode = ERROR_TIMER_BASETIME_START_INTERRUPT_FAILED;
		Error_Handler();
	}

	// =========================================================================
	// UART configuration
	// =========================================================================
	//
	// =========================================================================

	char uart1TxDmaBuffer[50];
	char uartRxDmaBuffer[50];

	strcpy(uart1TxDmaBuffer, "Teste da UART\r");

	ledTurnOff();
	HAL_GPIO_WritePin(NLED_GPIO_Port, NLED_Pin, GPIO_PIN_SET);
	halStatus = HAL_UART_Transmit_DMA(&huart1, (uint8_t *)uart1TxDmaBuffer, strlen(uart1TxDmaBuffer));
	if (halStatus != HAL_OK) {
		errorCode = ERROR_UART_TRANSMIT_POLLING_FAILED;
		Error_Handler();
	}
	HAL_GPIO_WritePin(NLED_GPIO_Port, NLED_Pin, GPIO_PIN_SET);
	halStatus = HAL_UART_Receive_DMA(&huart1, (uint8_t *)uartRxDmaBuffer, 50);
	if (halStatus != HAL_OK) {
		errorCode = ERROR_UART_TRANSMIT_POLLING_FAILED;
		Error_Handler();
	}

	CircularBuffer16 troiDax(200);
	funsapeStatus = troiDax.getLastError();




	/* USER CODE END 2 */

	/* Infinite loop */
	/* USER CODE BEGIN WHILE */
	while (1) {
		if (systemFlags.uart1RxHalfComplete) {
			for (uint8_t i = 0; i < 25; i++) {
				troiDax.push(uartRxDmaBuffer[i]);
			}
			systemFlags.uart1RxHalfComplete = false;
		}
		if (systemFlags.uart1RxFullComplete) {
			for (uint8_t i = 25; i < 50; i++) {
				troiDax.push(uartRxDmaBuffer[i]);
			}
			systemFlags.uart1RxFullComplete = false;
		}
		sprintf(uart1TxDmaBuffer, "buff = %d\r", troiDax.getOccupation());
		halStatus = HAL_UART_Transmit_DMA(&huart1, (uint8_t *)uart1TxDmaBuffer, strlen(uart1TxDmaBuffer));
		HAL_Delay(300);
		/* USER CODE END WHILE */

		/* USER CODE BEGIN 3 */
	}
	/* USER CODE END 3 */
}

/* USER CODE BEGIN 4 */

void HAL_ADC_ErrorCallback(ADC_HandleTypeDef *hadc)
{

}

void HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef *hadc)
{

}

void HAL_ADC_ConvHalfCpltCallback(ADC_HandleTypeDef *hadc)
{

}

void HAL_TIM_ErrorCallback(TIM_HandleTypeDef *htim)
{

}

void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{

}

void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart)
{
	systemFlags.uart1TxFullComplete = true;
}

void HAL_UART_TxHalfCpltCallback(UART_HandleTypeDef *huart)
{
	systemFlags.uart1TxHalfComplete = true;
}

void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
{
	systemFlags.uart1RxFullComplete = true;
}

void HAL_UART_RxHalfCpltCallback(UART_HandleTypeDef *huart)
{
	systemFlags.uart1RxHalfComplete = true;
}

void HAL_UART_ErrorCallback(UART_HandleTypeDef *huart)
{

}

void HAL_UART_AbortCpltCallback(UART_HandleTypeDef *huart)
{

}

void HAL_UART_AbortTransmitCpltCallback(UART_HandleTypeDef *huart)
{

}

void HAL_UART_AbortReceiveCpltCallback(UART_HandleTypeDef *huart)
{

}

/* USER CODE END 4 */

/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
	/* USER CODE BEGIN Error_Handler_Debug */
	/* User can add his own implementation to report the HAL error return state */

	__unused blinkWarning_s blinkCode;

	// Decode errorCode
	switch (errorCode) {
		case 0x0000 ... 0x000F:			// General error
			break;
		case 0x0010 ... 0x001F:			// Adc error
			break;
		case 0x0020 ... 0x002F:			// Timer error
			break;
		case 0x0030 ... 0xFFFE:			// Unmapped error
			break;
		case 0xFFFF:					// Unknown error
			break;
	}

	// Display error using RGB LED
	while (1) {
		ledToggle();
		HAL_Delay(500);
	}


	/* USER CODE END Error_Handler_Debug */
}

#ifdef  USE_FULL_ASSERT
/**
  * @brief  Reports the name of the source file and the source line number
  *         where the assert_param error has occurred.
  * @param  file: pointer to the source file name
  * @param  line: assert_param error line source number
  * @retval None
  */
void assert_failed(uint8_t *file, uint32_t line)
{
	/* USER CODE BEGIN 6 */
	/* User can add his own implementation to report the file name and line number,
	   tex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
	/* USER CODE END 6 */
}
#endif /* USE_FULL_ASSERT */

/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
