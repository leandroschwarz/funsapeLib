
#include "TM1637.hpp"

#define TM1637_I2C_COMM1    0x40
#define TM1637_I2C_COMM2    0xC0
#define TM1637_I2C_COMM3    0x80

#define digitalRead(m_pinDIO)			0

inlined void delayMicroseconds(uint16_t m_bitDelay)
{
	asm("NOP");
	asm("NOP");
	asm("NOP");
	asm("NOP");
	asm("NOP");
	asm("NOP");
	asm("NOP");
}

//
//      A
//     ---
//  F |   | B
//     -G-
//  E |   | C
//     ---
//      D

const uint8_t digitToSegment[] = {
// XGFEDCBA
	0b00111111,    // 0
	0b00000110,    // 1
	0b01011011,    // 2
	0b01001111,    // 3
	0b01100110,    // 4
	0b01101101,    // 5
	0b01111101,    // 6
	0b00000111,    // 7
	0b01111111,    // 8
	0b01101111,    // 9
	0b01110111,    // A
	0b01111100,    // b
	0b00111001,    // C
	0b01011110,    // d
	0b01111001,    // E
	0b01110001     // F
};

static const uint8_t minusSegments = 0b01000000;

TM1637Display::TM1637Display(Gpio *pinClk, Gpio *pinDIO, uint16_t bitDelay)
{
	// Copy the pin numbers
	this->m_pinClk = pinClk;
	this->m_pinDIO = pinDIO;
	m_bitDelay = bitDelay;

	// Set the pin direction and default value.
	// Both pins are set as inputs, allowing the pull-up resistors to pull them up
	// this->m_pinClk->set();
	// this->m_pinDIO->set();
}

void TM1637Display::setBrightness(uint8_t brightness, bool on)
{
	m_brightness = (brightness & 0x7) | (on ? 0x08 : 0x00);
}

void TM1637Display::setSegments(cuint8_t segments[], uint8_t length, uint8_t pos)
{
	// Write COMM1
	this->start();
	this->writeByte(TM1637_I2C_COMM1);
	this->stop();

	// Write COMM2 + first digit address
	this->start();
	this->writeByte(TM1637_I2C_COMM2 + (pos & 0x03));

	// Write the data bytes
	for(uint8_t k = 0; k < length; k++) {
		this->writeByte(segments[k]);
	}

	this->stop();

	// Write COMM3 + brightness
	this->start();
	this->writeByte(TM1637_I2C_COMM3 + (m_brightness & 0x0f));
	this->stop();
}

void TM1637Display::clear(void)
{
	uint8_t data[] = { 0, 0, 0, 0 };
	this->setSegments(data);
}

void TM1637Display::showNumberDec(int16_t num, bool leading_zero, uint8_t length, uint8_t pos)
{
	this->showNumberDecEx(num, 0, leading_zero, length, pos);
}

void TM1637Display::showNumberDecEx(int16_t num, uint8_t dots, bool leading_zero, uint8_t length, uint8_t pos)
{
	this->showNumberBaseEx(num < 0 ? -10 : 10, num < 0 ? -num : num, dots, leading_zero, length, pos);
}

void TM1637Display::showNumberHexEx(uint16_t num, uint8_t dots, bool leading_zero, uint8_t length, uint8_t pos)
{
	this->showNumberBaseEx(16, num, dots, leading_zero, length, pos);
}

void TM1637Display::showNumberBaseEx(uint8_t base, int16_t num, uint8_t dots, bool leading_zero, uint8_t length, uint8_t pos)
{
	bool negative = false;

	if(num < 0) {
		num = -num;
		negative = true;
	}

	uint8_t digits[4];

	if(num == 0 && !leading_zero) {
		// Singular case - take care separately
		for(uint8_t i = 0; i < (length - 1); i++) {
			digits[i] = 0;
		}
		digits[length - 1] = this->encodeDigit(0);
	} else {
		//uint8_t i = length-1;
		//if (negative) {
		//	// Negative number, show the minus sign
		//    digits[i] = minusSegments;
		//	i--;
		//}

		for(int i = length - 1; i >= 0; --i) {
			uint8_t digit = num % base;

			if(digit == 0 && num == 0 && leading_zero == false)
				// Leading zero is blank
			{
				digits[i] = 0;
			} else {
				digits[i] = this->encodeDigit(digit);
			}

			if(digit == 0 && num == 0 && negative) {
				digits[i] = minusSegments;
				negative = false;
			}

			num /= base;
		}
	}

	if(dots != 0) {
		this->showDots(dots, digits);
	}

	this->setSegments(digits, length, pos);
}

void TM1637Display::bitDelay()
{
	delayMicroseconds(m_bitDelay);
}

void TM1637Display::start()
{
	this->m_pinDIO->clr();
	this->bitDelay();
}

void TM1637Display::stop()
{
	this->m_pinDIO->clr();
	this->bitDelay();
	this->m_pinClk->set();
	this->bitDelay();
	this->m_pinDIO->set();
	this->bitDelay();
}

bool TM1637Display::writeByte(uint8_t b)
{
	uint8_t data = b;

	// 8 Data Bits
	for(uint8_t i = 0; i < 8; i++) {
		// CLK low
		this->m_pinClk->clr();
		this->bitDelay();

		// Set data bit
		if(data & 0x01) {
			this->m_pinDIO->set();
		} else {
			this->m_pinDIO->clr();
		}

		this->bitDelay();

		// CLK high
		this->m_pinClk->set();
		this->bitDelay();
		data = data >> 1;
	}

	// Wait for acknowledge
	// CLK to zero
	this->m_pinClk->clr();
	this->m_pinDIO->set();
	this->bitDelay();

	// CLK to high
	this->m_pinClk->set();
	this->bitDelay();
	uint8_t ack = digitalRead(m_pinDIO);			////// ATENCAOOOOO
	if(ack == 0) {
		this->m_pinDIO->clr();
	}


	this->bitDelay();
	this->m_pinClk->clr();
	this->bitDelay();

	return ack;
}

void TM1637Display::showDots(uint8_t dots, uint8_t *digits)
{
	for(int i = 0; i < 4; ++i) {
		digits[i] |= (dots & 0x80);
		dots <<= 1;
	}
}

uint8_t TM1637Display::encodeDigit(uint8_t digit)
{
	return digitToSegment[digit & 0x0f];
}
